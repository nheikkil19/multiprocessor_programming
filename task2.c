#include <stdio.h>
#include <stdlib.h>
#include "lodepng.h"
#include <math.h>

void readImage(char *filename, unsigned char **imageOut, unsigned *w, unsigned *h) {
    int err;
    err = lodepng_decode32_file(imageOut, w, h, filename);
    if (err) {
        printf("Error: Error when reading the image.");
    }
}

void writeImage(char *filename, unsigned char *image, unsigned w, unsigned h) {
    int err;
    unsigned bitdepth = 8;
    LodePNGColorType colortype = LCT_GREY;

    err = lodepng_encode_file(filename, image, w, h, colortype, bitdepth);
    if (err) {
        printf("Error: Error when saving the image.");
    }
}

void downscaleImage(unsigned char *imageIn, unsigned char **imageOut, unsigned w, unsigned h, unsigned factor) {
    unsigned hOut, wOut;
    unsigned subpixels = 4;
    hOut = h / factor;
    wOut = w / factor;
    *imageOut = (unsigned char *) malloc(sizeof(unsigned char) * wOut * hOut * subpixels);

    for (int i=0; i<hOut; i++) {
        for (int j=0; j<wOut; j++) {
            for (int k=0; k<subpixels; k++) {
                (*imageOut)[i*wOut*subpixels + j*subpixels + k] = imageIn[i*factor*w*subpixels + j*factor*subpixels + k];
            }
        }
    }
}

void grayscaleImage(unsigned char *imageIn, unsigned char **imageOut, unsigned w, unsigned h) {
    unsigned subpixels = 4;
    unsigned r, g, b;
    *imageOut = (unsigned char *) malloc(sizeof(unsigned char) * w * h);
    for (int i=0; i<h; i++) {
        for (int j=0; j<w; j++) {
            r = imageIn[i*w*subpixels + j*subpixels + 0];
            g = imageIn[i*w*subpixels + j*subpixels + 1];
            b = imageIn[i*w*subpixels + j*subpixels + 2];
            (*imageOut)[i*w + j] = (int) (0.2126 * r + 0.7152 * g + 0.0722 * b);
        }
    }
}

void calcZNCC(unsigned char *image1, unsigned char *image2, unsigned char **imageOut, unsigned w, unsigned h) {
    unsigned const MAX_DISP = 260/4;
    unsigned const WIN_SIZE = 9;
    double imgAvg1, imgAvg2;
    double zncc1, zncc2, zncc3, zncc;
    double znccBest, bestD;
    int x, y;
    unsigned count;
    int pixel;

    *imageOut = (unsigned char *) malloc(sizeof(unsigned char) * w * h);

    for (int j=0; j<h; j++) {
        for (int i=0; i<w; i++) {
            znccBest = -1;
            for (int d=0; d<MAX_DISP; d++) {

                // Calculate means over window
                imgAvg1 = 0;
                imgAvg2 = 0;
                count = 0;
                for (int win_y=0; win_y<WIN_SIZE; win_y++) {
                    y = j + win_y - WIN_SIZE/2;
                    // Do not go outside the image
                    if ( y >= 0 && y < h ) {
                        for (int win_x=0; win_x<WIN_SIZE; win_x++) {
                            x = i + win_x - WIN_SIZE/2;
                            // Do not go outside the image
                            if ( x >= 0 && x < w ) {
                                // Add pixel values
                                imgAvg1 += image1[y*w + x];
                                imgAvg2 += image2[y*w + x];
                                count++;
                            }
                        }
                    }
                }
                // Calculate mean
                imgAvg1 = imgAvg1 / count;
                imgAvg2 = imgAvg2 / count;

                // Calculate ZNCC
                zncc1 = 0;
                zncc2 = 0;
                zncc3 = 0;
                for (int win_y=0; win_y<WIN_SIZE; win_y++) {
                    y = j + win_y - WIN_SIZE/2;
                    // Do not go outside the image
                    if ( y >= 0 && y < h ) {
                        for (int win_x=0; win_x<WIN_SIZE; win_x++) {
                            x = i + win_x - WIN_SIZE/2;
                            // Do not go outside the image
                            if ( x-d >= 0 && x < w ) {
                                zncc1 += (image1[y*w + x] - imgAvg1) * (image2[y*w + x-d] - imgAvg2);
                                zncc2 += sqrt(pow((double)image1[y*w + x] - imgAvg1, 2));
                                zncc3 += sqrt(pow((double)image2[y*w + x-d] - imgAvg2, 2));
                            }
                        }
                    }
                }
                zncc = zncc1 / (zncc2 * zncc3);

                // Select if better than current best
                if (zncc > znccBest) {
                    znccBest = zncc;
                    bestD = d;
                }
            }
            (*imageOut)[j*w + i] = bestD;
        }
    }
}

// Function generated by GitHub Copilot with slight modifications
void normalizeImage(unsigned char *imageIn, unsigned char **imageOut, unsigned w, unsigned h) {
    unsigned min, max;
    min = 255;
    max = 0;
    for (int i=0; i<w*h; i++) {
        if (imageIn[i] < min) {
            min = imageIn[i];
        }
        if (imageIn[i] > max) {
            max = imageIn[i];
        }
    }
    *imageOut = (unsigned char *) malloc(sizeof(unsigned char) * w * h);
    for (int i=0; i<w*h; i++) {
        (*imageOut)[i] = (imageIn[i] - min) * 255 / (max - min);
    }
}


void crossCheck(unsigned char *image1, unsigned char *image2, unsigned char **imageOut, unsigned w, unsigned h) {
    const unsigned threshold = 8;
    *imageOut = (unsigned char *) malloc(sizeof(unsigned char) * w * h);
    for (int i=0; i<w*h; i++) {
        if (abs(image1[i] - image2[i]) > threshold) {
            (*imageOut)[i] = 0;
        }
        else {
            (*imageOut)[i] = image1[i];
        }

    }
}

void occlusionFill(unsigned char *imageIn, unsigned char **imageOut, unsigned w, unsigned h) {
    const int MAX_DIST = 10;
    *imageOut = (unsigned char *) malloc(sizeof(unsigned char) * w * h);
    for (int i=0; i<h; i++) {
        for (int j=0; j<w; j++) {
            if (imageIn[i*w + j] == 0) {
                for (int d=1; d<=MAX_DIST; d++) {
                    for (int x=-d+1; x<=d-1; x++) {
                        if (i+x>=0 && i+x<h) {
                            if (j-d>=0 && imageIn[(i+x)*w + j-d] != 0) {
                                (*imageOut)[i*w + j] = imageIn[(i+x)*w + j-d];
                                break;
                            }
                            else if (j+d<w && imageIn[(i+x)*w + j + d] != 0) {
                                (*imageOut)[i*w + j] = imageIn[(i+x)*w + j+d];
                                break;
                            }
                        }
                    }
                    for (int y=-d; y<=d; y++) {
                        if (j+y>=0 &&j+y<w) {
                            if (i-d>=0 && imageIn[(i-d)*w + j+y] != 0) {
                                (*imageOut)[i*w + j] = imageIn[(i-d)*w + j+y];
                                break;
                            }
                            else if (i+d<h && imageIn[(i+d)*w + j+y] != 0 ) {
                                (*imageOut)[i*w + j] = imageIn[(i+d)*w + j+y];
                                break;
                            }
                        }
                    }
                }
            }
            else {
                (*imageOut)[i*w + j] = imageIn[i*w + j];
            }
        }
    }
}

int main(void) {

    // Init variables
    char file1[] = "dataset\\im0.png";
    char file2[] = "dataset\\im1.png";
    char file3[] = "dataset\\crosscheck.png";
    unsigned char *image1, *image2, *imageDs1, *imageDs2, *imageGray1, *imageGray2, *imageZNCC1, *imageZNCC2, *imageNorm1, *imageNorm2, *imageCross, *imageOut;
    unsigned w, h, scaleFactor;

    // Read images
    readImage(file1, &image1, &w, &h);
    readImage(file2, &image2, &w, &h);

    // Downscale by four
    scaleFactor = 4;
    downscaleImage(image1, &imageDs1, w, h, scaleFactor);
    downscaleImage(image2, &imageDs2, w, h, scaleFactor);
    w = w / scaleFactor;
    h = h / scaleFactor;

    // Convert to grayscale
    grayscaleImage(imageDs1, &imageGray1, w, h);
    grayscaleImage(imageDs2, &imageGray2, w, h);

    // Do ZNCC
    calcZNCC(imageGray1, imageGray2, &imageZNCC1, w, h);
    calcZNCC(imageGray2, imageGray1, &imageZNCC2, w, h);

    // Normalize image
    normalizeImage(imageZNCC1, &imageNorm1, w, h);
    normalizeImage(imageZNCC2, &imageNorm2, w, h);

    // Cross checking
    crossCheck(imageNorm1, imageNorm2, &imageCross, w, h);

    // Occlusion fill
    occlusionFill(imageCross, &imageOut, w, h);

    // Save image
    writeImage(file3, imageOut, w, h);

    // Free memory
    free(image1);
    free(imageDs1);
    free(imageDs2);
    free(imageGray1);
    free(imageGray2);
    free(imageZNCC1);
    free(imageZNCC2);
    free(imageNorm1);
    free(imageNorm2);
    free(imageCross);
    free(imageOut);

    return 0;
}




